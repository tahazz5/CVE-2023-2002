#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include "bluetooth.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include "bluetooth.h"

// Fonction pour obtenir des privilèges
static int gain_privileges(void)
{
    // Créer un socket Bluetooth
    int fd = socket(PF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);

    // Créer un processus enfant
    int pid = fork();
    if (pid == 0) {
        // Rediriger la sortie d'erreur vers le socket
        dup2(fd, 2);
        close(fd);

        // Exécuter la commande sudo pour obtenir des privilèges
        execlp("sudo", "sudo", NULL);
        exit(EXIT_FAILURE);
    }

    // Attendre que le processus enfant se termine
    if (waitpid(pid, NULL, 0) < 0) {
        perror("waitpid");
        exit(EXIT_FAILURE);
    }

    return fd;
}

// Fonction pour se lier au canal de contrôle Bluetooth
static void bind_control_channel(int fd)
{
    struct sockaddr_hci haddr;

    haddr.hci_family = AF_BLUETOOTH;
    haddr.hci_dev = HCI_DEV_NONE;
    haddr.hci_channel = HCI_CHANNEL_CONTROL;

    if (bind(fd, (struct sockaddr *)&haddr, sizeof(haddr)) < 0) {
        perror("bind");
        exit(EXIT_FAILURE);
    }
}

// Fonction pour envoyer un paquet pour activer ou désactiver un périphérique
static void send_set_power(int fd, int index, int status)
{
    // Créer un buffer pour le paquet
    __u8 buffer[sizeof(struct mgmt_hdr) + sizeof(struct mgmt_mode)];
    struct mgmt_hdr *hdr = (struct mgmt_hdr *)buffer;
    struct mgmt_mode *cp = (struct mgmt_mode *)(hdr + 1);

    // Remplir les champs du paquet
    hdr->opcode = MGMT_OP_SET_POWERED;
    hdr->index = index;
    hdr->len = sizeof(*cp);
    cp->val = status;

    // Envoyer le paquet
    if (send(fd, buffer, sizeof(buffer), 0) < 0) {
        perror("send");
        exit(EXIT_FAILURE);
    }
}

// Fonction pour vérifier le résultat de la commande
static void check_cmd_result(int fd)
{
    // Créer un buffer pour la réponse
    __u8 buffer[sizeof(struct mgmt_hdr) + sizeof(struct mgmt_ev_cmd_status)];
    struct mgmt_hdr *hdr = (struct mgmt_hdr *)buffer;
    struct mgmt_ev_cmd_status *ev = (struct mgmt_ev_cmd_status *)(hdr + 1);
    ssize_t recved;

    // Recevoir la réponse
    recved = recv(fd, buffer, sizeof(buffer), 0);
    if (recved < 0) {
        perror("recv");
        exit(EXIT_FAILURE);
    }
    if (recved == 0) {
        fputs("recv: EOF\n", stderr);
        exit(EXIT_FAILURE);
    }
    if (recved < (ssize_t)sizeof(buffer)) {
        fputs("recv: Incomplete\n", stderr);
        exit(EXIT_FAILURE);
    }

    // Vérifier le statut de la commande
    if (ev->status == MGMT_STATUS_SUCCESS) {
        puts("Success!");
    } else {
        fprintf(stderr, "Failed. Reason: %s\n",
            stringify_mgmt_status(ev->status));
        exit(EXIT_FAILURE);
    }
}

// Fonction pour afficher un message d'utilisation
static _Noreturn void usage(char *prog)
{
    fprintf(stderr, "Usage: %s POWER_STATUS DEVICE_INDEX\n", prog);
    fputs("\tPOWER_STATUS := { up | down }\n", stderr);
    fputs("\tDEVICE_INDEX := { 0 | 1 | ... } \n", stderr);

    exit(EXIT_FAILURE);
}

// Fonction pour convertir une chaîne en un entier
static int parse_int(const char *str, int *res)
{
    char *end;

    *res = strtol(str, &end, 10);
    if (end == str || *end != '\0') {
        return -1;
    }

    return 0;
}

int main(int argc, char **argv)
{
    int power_status;
    int device_index;
    int fd;

    // Vérifier le nombre d'arguments
    if (argc != 3)
        usage(argv[0]);

    // Vérifier l'état du périphérique
    if (strcmp(argv[1], "up") == 0) {
        power_status = 1;
    } else if (strcmp(argv[1], "down") == 0) {
        power_status = 0;
    } else {
        fprintf(stderr, "invalid power status: %s\n\n", argv[1]);
        usage(argv[0]);
    }

    // Convertir l'index du périphérique en entier
    if (parse_int(argv[2], &device_index) != 0) {
        fprintf(stderr, "invalid device index: %s\n\n", argv[2]);
        usage(argv[0]);
    }

    // Obtenir des privilèges
    fd = gain_privileges();

    // Se lier au canal de contrôle Bluetooth
    bind_control_channel(fd);

    // Envoyer le paquet pour activer ou désactiver le périphérique
    send_set_power(fd, device_index, power_status);

    // Vérifier le résultat de la commande
    check_cmd_result(fd);

    // Fermer le descripteur de fichier
    close(fd);

    return 0;
}